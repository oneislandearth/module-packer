#!/usr/bin/env -S node --enable-source-maps

!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var a=n();for(var t in a)("object"==typeof exports?exports:e)[t]=a[t]}}(global,(function(){return(()=>{"use strict";var __webpack_modules__={94:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/filesystem.js + 3 modules\nvar filesystem = __webpack_require__(487);\n;// CONCATENATED MODULE: external \"child_process\"\nconst external_child_process_namespaceObject = require(\"child_process\");;\nvar external_child_process_default = /*#__PURE__*/__webpack_require__.n(external_child_process_namespaceObject);\n;// CONCATENATED MODULE: ./src/spawn.js\n// Import the spawn process\n\n\n// Define the spawn module\nconst spawn = (script, ...flags) => external_child_process_default().spawn(script, flags, { stdio: 'inherit' }).on('error', (error) => console.log(error));\n;// CONCATENATED MODULE: ./src/webpack.js\n// Import the required modules\n\n\n\n// Extract the flags\nconst [ ,,, ...flags ] = process.argv;\n\n// Define the path to the webpack cli\nconst cli = (0,filesystem.executablePath)('webpack');\n\n// Define the path to the webpack configuration\nconst config = (0,filesystem.resourcePath)('webpack/config.js');\n\n// Build the module using webpack and the configuration (plus any flags)\nconst build = () => spawn(cli, 'build', '-c', config, ...flags);\n\n// Build and watch the module using webpack and the configuration (plus any flags)\nconst watch = () => spawn(cli, 'build', '-c', config, '--watch', ...flags);\n\n// Build and serve the module using webpack and the configuration (plus any flags)\nconst serve = () => spawn(cli, 'serve', '-c', config, ...flags);\n;// CONCATENATED MODULE: ./src/ava.js\n// Import the required modules\n\n\n\n// Extract the flags\nconst [ ,,, ...ava_flags ] = process.argv;\n\n// Define the path to the ava cli\nconst ava = (0,filesystem.executablePath)('ava');\n\n// Run the module tests using ava (with any flags)\nconst test = () => spawn(ava, ...ava_flags);\n;// CONCATENATED MODULE: ./src/package.js\n// Import the filesystem module\n\n\n// Configure the package.json scripts\nconst appendScripts = () => {\n\n  // Read the package.json in the workspace\n  const packageData = (0,filesystem.readJSON)((0,filesystem.workspacePath)('package.json'));\n\n  // Check if there is a main script and add one if not\n  if (!packageData.main) packageData.main = 'lib/bundle.js';\n\n  // Check if there are scripts in the package.json, and add if not\n  if (!packageData.scripts) packageData.scripts = {};\n\n  // Check if there is a prepublish script and add one if not\n  if (!packageData.scripts.prepublish) packageData.scripts.prepublish = 'npm run build';\n\n  // Check if there is a build script and add one if not\n  if (!packageData.scripts.build) packageData.scripts.build = 'module-packer build';\n\n  // Check if there is a serve script and add one if not\n  if (!packageData.scripts.serve) packageData.scripts.serve = 'module-packer serve';\n\n  // Check if there is a watch script and add one if not\n  if (!packageData.scripts.watch) packageData.scripts.watch = 'module-packer watch';\n\n  // Check if there is a test script and add one if not\n  if (!packageData.scripts.test) packageData.scripts.test = 'module-packer test';\n\n  // Update the package.json file\n  (0,filesystem.writeJSON)((0,filesystem.workspacePath)('package.json'), packageData);\n};\n\n// Configure the package.json scripts\nconst initPackage = (name) => {\n\n  // Determine the name from the directory if not set\n  if (!name) name = filesystem.workspaceDirectory.replace(/(?:\\/.*\\/)(.*)(?:\\/*)/gm, (m, n) => n);\n\n  // Read the version of the package\n  const { version } = (0,filesystem.readJSON)((0,filesystem.packagePath)('package.json'));\n\n  // Read the package.json in the resources\n  let packageData = (0,filesystem.readFile)((0,filesystem.resourcePath)('npm/package.json'));\n\n  // Replace the module name in the the package data\n  packageData = packageData.replace(/(\\$MODULE)/gm, name);\n\n  // Replace the version in the the package data\n  packageData = packageData.replace(/(\\$VERSION)/gm, version);\n\n  // Save the package.json file\n  (0,filesystem.writeFile)((0,filesystem.workspacePath)('package.json'), packageData);\n};\n\n\n// Clear the devDependencies of the package.json when installing (postinstall)\nconst clearDependencies = () => {\n\n  // Read the package.json in the workspace\n  const packageData = (0,filesystem.readJSON)((0,filesystem.workspacePath)('package.json'));\n\n  // Clear the devDependencies\n  packageData.devDependencies = {};\n\n  // Update the package.json file\n  (0,filesystem.writeJSON)((0,filesystem.workspacePath)('package.json'), packageData);\n};\n;// CONCATENATED MODULE: ./src/postinstall.js\n// Import the filesystem module\n\n\n// Import the package module\n\n\n// Handle the postinstall events\nconst postinstall = () => {\n\n  // Return if the workspace is the current package\n  if (filesystem.isPackage) return;\n\n  // Copy the travis files\n  (0,filesystem.copyResource)('travis/.travis.yml', '.travis.yml');\n\n  // Copy the git files\n  (0,filesystem.copyResource)('git/git-ignore', '.gitignore');\n  (0,filesystem.copyResource)('git/pre-commit', '.git/hooks/pre-commit');\n\n  // Copy the npm files\n  (0,filesystem.copyResource)('npm/.npmignore', '.npmignore');\n\n  // Configure the the linter files\n  (0,filesystem.copyResource)('eslint/.eslintignore', '.eslintignore');\n  (0,filesystem.linkResource)('eslint/.eslintrc.js', '.eslintrc.js');\n\n  // Configure vscode\n  (0,filesystem.createDirectory)((0,filesystem.workspacePath)('.vscode'));\n  (0,filesystem.copyResource)('vscode/settings.json', '.vscode/settings.json');\n  (0,filesystem.copyResource)('vscode/jsconfig.json', 'jsconfig.json');\n\n  // Configure ava\n  (0,filesystem.copyResource)('ava/ava.config.js', 'ava.config.js');\n\n  // Check for a package.json file and append the scripts\n  if ((0,filesystem.workspacePathExists)('package.json')) {\n\n    // Append the package scripts\n    appendScripts();\n\n  // Since the package.json doesn't exist, create one\n  } else {\n\n    // Create the package.json\n    initPackage();\n\n    // Clear the dependencies\n    clearDependencies();\n  }\n};\n;// CONCATENATED MODULE: ./src/init.js\n// Import the package module\n\n\n// Extract the name\nconst [ ,,, init_name, ...init_flags ] = process.argv;\n\n// Handle the init events\nconst init = () => initPackage(init_name, ...init_flags);\n;// CONCATENATED MODULE: ./src/cli.js\n// Require('source-map-support').install();\n\n// Import the webpack module\n\n\n// Import the ava module\n\n\n// Import the postinstall module\n\n\n// Import the init module\n\n\n// Handle when there aren't any arguments\nif (process.argv.length < 3) {\n  \n  // Log the usage options for the CLI\n  console.log();\n  console.log('\\x1b[0m\\x1b[35m\\x1b[1m@oneisland/module-packer\\x1b[0m\\n');\n  console.log('\\x1b[35m    init \\x1b[2m[name]\\x1b[0m');\n  console.log('\\x1b[2m    (setup a new library or module)\\x1b[0m\\n');\n  console.log('\\x1b[35m    build \\x1b[2m[webpack-cli-flags]\\x1b[0m');\n  console.log('\\x1b[2m    (package up a library or module using webpack)\\x1b[0m\\n');\n  console.log('\\x1b[35m    watch \\x1b[2m[webpack-cli-flags]\\x1b[0m');\n  console.log('\\x1b[2m    (package up and watch for library or module changes using webpack -w)\\x1b[0m\\n');\n  console.log('\\x1b[35m    serve \\x1b[2m[webpack-cli-flags]\\x1b[0m');\n  console.log('\\x1b[2m    (package up and serve a library or module using webpack serve)\\x1b[0m\\n');\n  console.log('\\x1b[35m    test \\x1b[2m[ava-flags]\\x1b[0m');\n  console.log('\\x1b[2m    (execute any tests defined in the libary or module using ava)\\x1b[0m\\n');\n  console.log();\n\n  // Exit the application\n  process.exit(0);\n}\n\n// Extract the command and arguments\nconst [,, command, ...cli_flags] = process.argv;\n\n// Define the commands set\nconst commands = { build: build, serve: serve, watch: watch, test: test, postinstall: postinstall, init: init };\n\n// Run the appropriate command\ncommands[command](cli_flags);\n\n//# sourceURL=/media/data/OneIsland/Software/module-packer/src/cli.js%7Ca001594947ea0f1beae6ee6c346d239f")},487:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "copyResource": () => (/* binding */ copyResource),\n  "createDirectory": () => (/* binding */ createDirectory),\n  "executablePath": () => (/* binding */ executablePath),\n  "findRootDirectory": () => (/* binding */ findRootDirectory),\n  "isPackage": () => (/* binding */ isPackage),\n  "linkResource": () => (/* binding */ linkResource),\n  "modulePath": () => (/* binding */ modulePath),\n  "modulesDirectory": () => (/* binding */ modulesDirectory),\n  "packageDirectory": () => (/* binding */ packageDirectory),\n  "packagePath": () => (/* binding */ packagePath),\n  "pathExists": () => (/* binding */ pathExists),\n  "readFile": () => (/* binding */ readFile),\n  "readJSON": () => (/* binding */ readJSON),\n  "removeDirectory": () => (/* binding */ removeDirectory),\n  "resourceDirectory": () => (/* binding */ resourceDirectory),\n  "resourcePath": () => (/* binding */ resourcePath),\n  "resourcePathExists": () => (/* binding */ resourcePathExists),\n  "temporaryDirectory": () => (/* binding */ temporaryDirectory),\n  "temporaryPath": () => (/* binding */ temporaryPath),\n  "workspaceDirectory": () => (/* binding */ workspaceDirectory),\n  "workspacePath": () => (/* binding */ workspacePath),\n  "workspacePathExists": () => (/* binding */ workspacePathExists),\n  "writeFile": () => (/* binding */ writeFile),\n  "writeJSON": () => (/* binding */ writeJSON)\n});\n\n;// CONCATENATED MODULE: external "fs"\nconst external_fs_namespaceObject = require("fs");;\n;// CONCATENATED MODULE: external "path"\nconst external_path_namespaceObject = require("path");;\n;// CONCATENATED MODULE: external "os"\nconst external_os_namespaceObject = require("os");;\n;// CONCATENATED MODULE: ./src/filesystem.js\n// Import the os, ilesystem and path modules\n\n\n\n\n// Define the package name\nconst packageID = \'@oneisland/module-packer\';\n\n// Read a file\nconst readFile = (path) => (0,external_fs_namespaceObject.readFileSync)(path, { encoding: \'utf-8\' });\n\n// Write a file\nconst writeFile = (path, content) => (0,external_fs_namespaceObject.writeFileSync)(path, content);\n\n// Read a file as JSON\nconst readJSON = (path) => JSON.parse(readFile(path));\n\n// Write a file as JSON\nconst writeJSON = (path, content) => writeFile(path, JSON.stringify(content, null, 2));\n\n// Search recursively for a package root\nconst findRootDirectory = (directory, namecheck) => {\n\n  // Return the module directory as \'none\' when there is no workspace\n  if (directory == \'/\') return \'none\';\n\n  // Check for a package.json file\n  if ((0,external_fs_namespaceObject.existsSync)((0,external_path_namespaceObject.resolve)(directory, \'package.json\'))) {\n\n    // Read the package.json file\n    const { name } = readJSON((0,external_path_namespaceObject.resolve)(directory, \'package.json\'));\n\n    // Check the name matches as expected and return the directory if so\n    if (namecheck && namecheck(name)) return directory;\n\n  // Check for a node modules folder\n  } else if ((0,external_fs_namespaceObject.existsSync)((0,external_path_namespaceObject.resolve)(directory, \'node_modules\'))) return directory;\n\n  // Recursively search up a directory\n  return findRootDirectory((0,external_path_namespaceObject.resolve)(directory, \'../\'), (namecheck) ? namecheck : null);\n};\n\n// Define the temporary directory\nconst temporaryDirectory = (0,external_fs_namespaceObject.mkdtempSync)((0,external_path_namespaceObject.join)((0,external_os_namespaceObject.tmpdir)(), \'omp-\'));\n\n// Define the workspace root directory\nconst workspaceDirectory = findRootDirectory(process.cwd(), (name) => name != packageID).replace(/node_modules.*/, \'\');\n\n// Define the package root directory\nconst packageDirectory = findRootDirectory(__dirname, (name) => name == packageID);\n\n// Define the node modules directory\nconst modulesDirectory = (0,external_path_namespaceObject.join)(packageDirectory.replace(/node_modules.*/, \'\'), \'/node_modules\');\n\n// Define the package resource directory\nconst resourceDirectory = (0,external_path_namespaceObject.join)(packageDirectory, \'/resources\');\n\n// Determine the path for a temporary file\nconst temporaryPath = (file) => (0,external_path_namespaceObject.join)(temporaryDirectory, \'/\', file);\n\n// Determine the path for a workspace file\nconst workspacePath = (file) => (0,external_path_namespaceObject.join)(workspaceDirectory, \'/\', file);\n\n// Determine the path for a package file\nconst packagePath = (file) => (0,external_path_namespaceObject.join)(packageDirectory, \'/\', file);\n\n// Determine the path for a node module\nconst modulePath = (file) => (0,external_path_namespaceObject.join)(modulesDirectory, \'/\', file);\n\n// Determine the path for a node executable\nconst executablePath = (file) => (0,external_path_namespaceObject.join)(modulesDirectory, \'/.bin/\', file);\n\n// Determine the path for a resource file\nconst resourcePath = (file) => (0,external_path_namespaceObject.join)(resourceDirectory, \'/\', file);\n\n// Determine if a path exists\nconst pathExists = (path) => (0,external_fs_namespaceObject.existsSync)(path);\n\n// Determine if a file exists at the workspace path\nconst workspacePathExists = (file) => pathExists(workspacePath(file));\n\n// Determine if a file exists at the resource path\nconst resourcePathExists = (file) => pathExists(resourcePath(file));\n\n// Determine if the current root workspace is this package (e.g. npm link installing)\nconst isPackage = (workspaceDirectory == \'none\');\n\n// Symbolically link a resource file to the workspace\nconst linkResource = (resource, target) => {\n  \n  // Check that there is a resource to be linked and there is no file at the target\n  if (resourcePathExists(resource) && !workspacePathExists(target)) {\n\n    // Attempt to symlink\n    try {\n\n      console.log(resourcePath(resource));\n\n      // Symbolically link the resource\n      (0,external_fs_namespaceObject.symlinkSync)(resourcePath(resource), workspacePath(target));\n    \n    // Ignore the error as the file exists\n    } catch (e) {\n\n      // Log the error\n      console.error(e);\n    }\n  }\n};\n\n// Copy a resource file to the workspace\nconst copyResource = (resource, target) => {\n  \n  // Check that there is a resource to be copied and there is no file at the target\n  if (resourcePathExists(resource) && !workspacePathExists(target)) {\n\n    // Copy the file\n    (0,external_fs_namespaceObject.copyFileSync)(resourcePath(resource), workspacePath(target));\n  }\n};\n\n// Create a directory\nconst createDirectory = (path) => {\n\n  // Check if the directory already exists and creat one if not\n  if (!pathExists(path)) (0,external_fs_namespaceObject.mkdirSync)(path); \n};\n\n// Remove a directory\nconst removeDirectory = (directory, recursive) => (0,external_fs_namespaceObject.rmdirSync)(directory, { recursive });\n\n// Remove the temporary directory on exit\nprocess.on(\'exit\', () => removeDirectory(temporaryDirectory, true));\n\n//# sourceURL=/media/data/OneIsland/Software/module-packer/src/filesystem.js%7Ce4201c28ccee487d3e583c373afd5705')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var a=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](a,a.exports,__webpack_require__),a.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var a in n)__webpack_require__.o(n,a)&&!__webpack_require__.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(94);return __webpack_exports__})()}));
//# sourceMappingURL=cli.js.map